https://ko.javascript.info/closure

# 변수의 유효범위와 클로저

## 코드 블록
- 코드 블록 `{...}`안에서 선언한 변수는 블록 안에서만 사용 할 수 있음.
- `if`, `for`, `while`등에서도 마찬가지로 코드블록 안에서 선언한 변수는 오직 블록 안에서만 접근 가능


## 중첩 함수
함수 내부에서 선언한 함수를 '중첩(nested)'함수라고 부름. 

코드 정돈하는데 사용 가능


# !렉시컬 환경!
## 단계 1. 변수
자바스크립트에선 실행중인 함수, 코드 블록 `{...}``, 스크립트 전체는 렉시컬 환경(Lexical Encironment)라 불리는 내무 숨김 연관 객채(internal hidden associated object)를 갖음.

렉시컬 환경의 객체는 두 부분으로 구성됨
- 1. 환경레코드(Environment record): 모든 지역 변수를 프로퍼티로 저장하고 있는 객체. `this`값과 같은 기타 정보도 여기에 저장됨.
- 2. 외부 렉시컬 환경(Outer Lexical Invironment)에 대한 참조: 외부 코드와 연관됨

**`변수`는 특수 내부 객체인 `환경 레코드`의 프로퍼티일 뿐입니다. '변수를 가져오거나 변경'하는 것은 '환경 레코드로의 프로퍼티를 가져오거나 변경'함을 의미함.**

- 변수는 특수 내부 객체인 환경 레코드의 프로퍼티. 환경 레코드는 현재 실행중인 함수와 코드 블록, 스크립트와 연관되어 있음.
- 변수를 변경하면 환경 레코드의 프로퍼티가 변경됨.

## 단계 2. 함수 선언문
함수는 변수와 마찬가지로 값임.

**다만 함수 선언문(function declaration)으로 선언한 함수는 일반 변수와 달리 바로 초기화 됨.**

함수 선언문으로 선언한 함수는 렉시컬 환경이 만들어지는 즉시 사용 가능. 변수는 `let`을 만나 선언 될 때까지 사용 할수 없지만요.

`let say = function(name)...`같이 함수를 변수에 할당한 함수 표현식은 해당하지 않습니다.

## 단계 3. 내부와 외부 렉시컬 환경

함수를 호출하면 호출할 때 마다 새로운 렉시컬 환경 객체가 만들어지고 여기엔 함수를 실행하는데 필요한 변수들이 저장됨.

이 렉시컬 환경엔 함수 호출 시 넘겨받은 매개변수와 함수의 지역 변수가 저장됨.

내부 렉시컬 환경은 외부 렉시컬 환경에 대한 참조를 갖습니다.

**코드에서 변수에 접근할 땐, 먼저 내부 렉시컬 환경을 검색 범위로 잡습니다. 내부 렉시컬 환경에서 원하는 변수를 찾지 못하면 검색범위를 내부 렉시컬 환경이 참조하는 외부 렉시컬 환경으로 확장합니다.**
**이 과정은 검색 범위가 전역 렉시컬 환경이 될 때 까지 반복합니다.**

## 단계 4. 반환 함수
모든 함수는 함수가 생성된 곳의 렉시컬 환경을 기억함. 

함수는 `[[Environment]]`라 불리는 숨김 프로퍼티를 갖는데, 이곳에 함수가 만들어진 곳의 렉시컬 환경에 대한 참조가 저장됨.

함수가 생성될 때 딱 한번 그 값이 세팅되고 영원히 변하지 않음.

**변숫값 갱신은 변수가 저장된 렉시컬 환경에서 이뤄짐.**

> **클로저!**
> 외부 변수를 기억하고 이 외부변수에 접근할 수 있는 함수를 말함. 자바스크립트에선 모든 함수가 자연스럽게 클로저가 됨.
> 요점을 정리해 봅시다. 자바스크립트의 함수는 숨김 프로퍼티인 [[Environment]]를 이용해 자신이 어디서 만들어졌는지를 기억합니다. 
> 함수 내부의 코드는 [[Environment]]를 사용해 외부 변수에 접근합니다.
> 프런트엔드 개발자 채용 인터뷰에서 "클로저가 무엇입니까?"라는 질문을 받으면, 클로저의 정의를 말하고 자바스크립트에서 왜 모든 함수가 클로저인지에 관해 설명하면 될 것 같습니다. 
> 이때 [[Environment]] 프로퍼티와 렉시컬 환경이 어떤 방식으로 동작하는지에 대한 설명을 덧붙이면 좋습니다.

## 가비지 컬렉션
함수 호출이 끝나면 함수에 대응하는 렉시컬 환경이 메모리에서 제거됨.

함수와 관련된 변수들은 이 때 모두 사라져서 함수 호출이 끝나면 관련 변수를 참조 할수 없는 이유임. 자바스크립트에서 모든 객체는 도달 가능한 상태일 때만 메모리에 유지됨.

그런데 호출이 끝나도 여전히 도달 가능한 중첩 함수가 있을 수 있는데 이때는 중첩함수의 `[[Environment]]`프로퍼티에 외부 함수 렉시컬 한경에 대한 정보가 저장되어서 도달 가능한 상태가 됨.
```javascript
// 중첩함수를 사용할때 함수를 여러번 호출하고 그 결과를 어딘가에 저장하는 경우
// 호출시 만들어지는 각 렉시컬 환경 모두가 메모리에 유지됨.
function f() {
  let value = 123;

  return function() {
    alert(value);
  }
}

let g = f(); // g.[[Environment]]에 f() 호출 시 만들어지는
// 렉시컬 환경 정보가 저장됩니다.


// 다른 객체와 마찬가지로 도달할 수 없을 때 메모리에서 삭제됨. 
// 해당 객체를 참조하는 중첩 함수가 하나라도 있으면 사라지지 않음.
// 중첩 함수가 메모리에서 삭제되어야 이를 감싸는 렉시컬 환경도 메모리에서 제거됨.
function f() {
  let value = 123;

  return function() {
    console.log(value);
  }
}

let g = f(); // g가 살아있는 동안엔 연관 렉시컬 환경도 메모리에 살아있음

g = null; // 도달 할 수 없는 상태이므로 메모리에서 삭제됨

console.log(g); // null
```

### 최적화 프로세스
함수가 살아있는 동안엔 이론상으로 모든 외부 변수도 메모리에 유지되는데, 실제로는 자바스크립트 엔진이 변수 사용을 분석하고 외부변수가 사용되지 않는다고 생각되면 메모리에서 제거함.
**디버깅 시, 최적화 과정에서 제거된 변수를 사용할 수 없다는 점은 V8엔진(Chrome, Opera에서 쓰임)의 주요 부작용입니다.**



